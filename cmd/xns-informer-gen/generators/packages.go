package generators

import (
	"path"
	"path/filepath"
	"sort"
	"strings"

	"k8s.io/code-generator/cmd/client-gen/generators/util"
	clientgentypes "k8s.io/code-generator/cmd/client-gen/types"
	"k8s.io/klog/v2"

	"k8s.io/gengo/args"
	"k8s.io/gengo/generator"
	"k8s.io/gengo/namer"
	"k8s.io/gengo/types"
)

var headerText = []byte("// Code generated by xns-informer-gen. DO NOT EDIT.\n\n")

// TODO: This should be configurable via CustomArgs.
var pluralExceptions = map[string]string{"Endpoints": "Endpoints"}

const xnsinformersPkg = "github.com/maistra/xns-informer/pkg/informers"

type CustomArgs struct {
	ListersPackage   string
	InformersPackage string
}

// NameSystems returns the name system used by the generators in this package.
func NameSystems() namer.NameSystems {
	return namer.NameSystems{
		"public":             namer.NewPublicNamer(0),
		"private":            namer.NewPrivateNamer(0),
		"allLowercasePlural": namer.NewAllLowercasePluralNamer(pluralExceptions),
		"publicPlural":       namer.NewPublicPluralNamer(pluralExceptions),
	}
}

// DefaultNameSystem returns the default name system for ordering the types to be
// processed by the generators in this package.
func DefaultNameSystem() string {
	return "public"
}

func Packages(c *generator.Context, args *args.GeneratorArgs) generator.Packages {
	customArgs, ok := args.CustomArgs.(*CustomArgs)
	if !ok {
		klog.Fatal("Invalid type for CustomArgs")
	}

	var packages []generator.Package
	groupVersions := make(map[string]clientgentypes.GroupVersions)
	typesForGroupVersion := make(map[clientgentypes.GroupVersion][]*types.Type)
	groupGoNames := make(map[string]string)

	for _, inputDir := range args.InputDirs {
		p := c.Universe.Package(inputDir)

		gv := clientgentypes.GroupVersion{}
		parts := strings.Split(p.Path, "/")
		gv.Group = clientgentypes.Group(parts[len(parts)-2])
		gv.Version = clientgentypes.Version(parts[len(parts)-1])

		typesToGenerate := make([]*types.Type, 0)
		for _, t := range p.Types {
			tags := util.MustParseClientGenTags(append(t.SecondClosestCommentLines, t.CommentLines...))
			if !tags.GenerateClient || tags.NoVerbs || !tags.HasVerb("list") || !tags.HasVerb("watch") {
				continue
			}

			typesToGenerate = append(typesToGenerate, t)

			if _, ok := typesForGroupVersion[gv]; !ok {
				typesForGroupVersion[gv] = []*types.Type{}
			}
			typesForGroupVersion[gv] = append(typesForGroupVersion[gv], t)
		}

		if len(typesToGenerate) == 0 {
			continue
		}

		sort.Slice(typesToGenerate, func(i, j int) bool {
			return typesToGenerate[i].Name.Name < typesToGenerate[j].Name.Name
		})

		groupPackageName := gv.Group.NonEmpty()
		gvPackage := path.Clean(p.Path)

		// If there's a comment of the form "// +groupGoName=SomeUniqueShortName", use that as
		// the Go group identifier in CamelCase. It defaults
		groupGoNames[groupPackageName] = namer.IC(strings.Split(gv.Group.NonEmpty(), ".")[0])
		if override := types.ExtractCommentTags("+", p.Comments)["groupGoName"]; override != nil {
			groupGoNames[groupPackageName] = namer.IC(override[0])
		}

		groupVersionsEntry, ok := groupVersions[groupPackageName]
		if !ok {
			groupVersionsEntry = clientgentypes.GroupVersions{
				PackageName: groupPackageName,
				Group:       gv.Group,
			}
		}
		groupVersionsEntry.Versions = append(groupVersionsEntry.Versions, clientgentypes.PackageVersion{Version: gv.Version, Package: gvPackage})
		groupVersions[groupPackageName] = groupVersionsEntry

		listersPkg := path.Join(customArgs.ListersPackage, groupPackageName, gv.Version.NonEmpty())
		informersPkg := path.Join(customArgs.InformersPackage, groupPackageName, gv.Version.NonEmpty())
		outputPath := filepath.Join(groupPackageName, string(gv.Version))

		packages = append(packages, &generator.DefaultPackage{
			PackageName: string(gv.Version),
			PackagePath: outputPath,
			HeaderText:  headerText,

			GeneratorFunc: func(c *generator.Context) []generator.Generator {
				var generators []generator.Generator

				generators = append(generators, &versionInterfaceGenerator{
					DefaultGen: generator.DefaultGen{
						OptionalName: "interface",
					},
					informersPackage: informersPkg,
					groupVersion:     gv,
					types:            typesToGenerate,
				})

				for _, t := range typesToGenerate {
					generators = append(generators, &informerGenerator{
						DefaultGen: generator.DefaultGen{
							OptionalName: strings.ToLower(t.Name.Name),
						},
						imports:          generator.NewImportTracker(t),
						listersPackage:   listersPkg,
						informersPackage: informersPkg,
						groupVersion:     gv,
						typeToGenerate:   t,
					})
				}
				return generators
			},
		})
	}

	for group, versions := range groupVersions {
		// need to create our own vars to capture in closure below
		groupName := group
		gvs := versions
		outputPackage := path.Join(args.OutputPackagePath, group)
		packages = append(packages, &generator.DefaultPackage{
			PackageName: group,
			PackagePath: group,
			HeaderText:  headerText,

			GeneratorFunc: func(c *generator.Context) (generators []generator.Generator) {
				generators = append(generators, &groupInterfaceGenerator{
					DefaultGen: generator.DefaultGen{
						OptionalName: "interface",
					},
					group:         groupName,
					versions:      gvs,
					outputPackage: outputPackage,
					imports:       generator.NewImportTracker(),
				})
				return generators
			},
		})
	}

	// top-level factory package
	packages = append(packages, &generator.DefaultPackage{
		PackageName: filepath.Base(args.OutputPackagePath),
		HeaderText:  headerText,

		GeneratorFunc: func(c *generator.Context) (generators []generator.Generator) {
			groups := make([]string, len(groupVersions))
			for g := range groupVersions {
				groups = append(groups, g)
			}

			sort.Strings(groups)

			generators = append(generators, &factoryGenerator{
				DefaultGen: generator.DefaultGen{
					OptionalName: "factory",
				},
				groups:        groups,
				outputPackage: args.OutputPackagePath,
				imports:       generator.NewImportTracker(),
			})

			generators = append(generators, &genericGenerator{
				DefaultGen: generator.DefaultGen{
					OptionalName: "generic",
				},
				outputPackage:        args.OutputPackagePath,
				imports:              generator.NewImportTracker(),
				groupVersions:        groupVersions,
				pluralExceptions:     pluralExceptions,
				typesForGroupVersion: typesForGroupVersion,
				groupGoNames:         groupGoNames,
			})
			return generators
		},
	})

	return packages
}
