package generators

import (
	"path"
	"path/filepath"
	"sort"
	"strings"

	"k8s.io/code-generator/cmd/client-gen/generators/util"
	"k8s.io/klog/v2"

	"k8s.io/gengo/args"
	"k8s.io/gengo/generator"
	"k8s.io/gengo/namer"
	"k8s.io/gengo/types"
)

var headerText = []byte("// Code generated by xns-informer-gen. DO NOT EDIT.\n\n")

// TODO: This should be configurable via CustomArgs.
var pluralExceptions = map[string]string{"Endpoints": "Endpoints"}

const xnsinformersPkg = "github.com/maistra/xns-informer/pkg/informers"

type CustomArgs struct {
	ListersPackage   string
	InformersPackage string
}

type GroupVersion struct {
	Group   string
	Version string
}

// NameSystems returns the name system used by the generators in this package.
func NameSystems() namer.NameSystems {
	return namer.NameSystems{
		"public":             namer.NewPublicNamer(0),
		"private":            namer.NewPrivateNamer(0),
		"allLowercasePlural": namer.NewAllLowercasePluralNamer(pluralExceptions),
		"publicPlural":       namer.NewPublicPluralNamer(pluralExceptions),
	}
}

// DefaultNameSystem returns the default name system for ordering the types to be
// processed by the generators in this package.
func DefaultNameSystem() string {
	return "public"
}

func Packages(c *generator.Context, args *args.GeneratorArgs) generator.Packages {
	customArgs, ok := args.CustomArgs.(*CustomArgs)
	if !ok {
		klog.Fatal("Invalid type for CustomArgs")
	}

	var packages []generator.Package
	groupVersions := make(map[string][]string)

	for _, inputDir := range args.InputDirs {
		p := c.Universe.Package(inputDir)

		typesToGenerate := make([]*types.Type, 0)
		for _, t := range p.Types {
			tags := util.MustParseClientGenTags(append(t.SecondClosestCommentLines, t.CommentLines...))
			if !tags.GenerateClient || tags.NoVerbs || !tags.HasVerb("list") || !tags.HasVerb("watch") {
				continue
			}

			typesToGenerate = append(typesToGenerate, t)
		}

		if len(typesToGenerate) == 0 {
			continue
		}

		sort.Slice(typesToGenerate, func(i, j int) bool {
			return typesToGenerate[i].Name.Name < typesToGenerate[j].Name.Name
		})

		gv := GroupVersion{}
		parts := strings.Split(p.Path, "/")
		gv.Group = parts[len(parts)-2]
		gv.Version = parts[len(parts)-1]

		if _, ok := groupVersions[gv.Group]; !ok {
			groupVersions[gv.Group] = make([]string, 0)
		}

		groupVersions[gv.Group] = append(groupVersions[gv.Group], gv.Version)

		listersPkg := path.Join(customArgs.ListersPackage, gv.Group, gv.Version)
		informersPkg := path.Join(customArgs.InformersPackage, gv.Group, gv.Version)
		outputPath := filepath.Join(gv.Group, gv.Version)

		packages = append(packages, &generator.DefaultPackage{
			PackageName: gv.Version,
			PackagePath: outputPath,
			HeaderText:  headerText,

			GeneratorFunc: func(c *generator.Context) []generator.Generator {
				var generators []generator.Generator

				generators = append(generators, &versionInterfaceGenerator{
					DefaultGen: generator.DefaultGen{
						OptionalName: "interface",
					},
					informersPackage: informersPkg,
					groupVersion:     gv,
					types:            typesToGenerate,
				})

				for _, t := range typesToGenerate {
					generators = append(generators, &informerGenerator{
						DefaultGen: generator.DefaultGen{
							OptionalName: strings.ToLower(t.Name.Name),
						},
						imports:          generator.NewImportTracker(t),
						listersPackage:   listersPkg,
						informersPackage: informersPkg,
						groupVersion:     gv,
						typeToGenerate:   t,
					})
				}
				return generators
			},
		})
	}

	for group := range groupVersions {
		versions := groupVersions[group]
		sort.Strings(versions)

		outputPackage := path.Join(args.OutputPackagePath, group)
		packages = append(packages, &generator.DefaultPackage{
			PackageName: group,
			PackagePath: group,
			HeaderText:  headerText,

			GeneratorFunc: func(c *generator.Context) (generators []generator.Generator) {
				generators = append(generators, &groupInterfaceGenerator{
					DefaultGen: generator.DefaultGen{
						OptionalName: "interface",
					},
					group:         group,
					versions:      versions,
					outputPackage: outputPackage,
					imports:       generator.NewImportTracker(),
				})
				return generators
			},
		})
	}

	// top-level factory package
	packages = append(packages, &generator.DefaultPackage{
		PackageName: filepath.Base(args.OutputPackagePath),
		HeaderText:  headerText,

		GeneratorFunc: func(c *generator.Context) (generators []generator.Generator) {
			groups := make([]string, len(groupVersions))
			for g := range groupVersions {
				groups = append(groups, g)
			}

			sort.Strings(groups)

			generators = append(generators, &factoryGenerator{
				DefaultGen: generator.DefaultGen{
					OptionalName: "factory",
				},
				groups:        groups,
				outputPackage: args.OutputPackagePath,
				imports:       generator.NewImportTracker(),
			})
			return generators
		},
	})

	return packages
}
